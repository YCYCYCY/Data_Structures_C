//KMP算法
//每当一趟匹配过程中出现字符比较不相等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较。
//当匹配过程中产生“失配”，即主串S中的第i个字符与模式串p中第j个字符“失配”时，主串中第i个字符应与模式串中第几个字符再比较？
//假设此时应与第k个字符继续比较，则模式串中前k-1个字符的子串必须满足=si-k+1 si-k+2 ...si-1
//又由前面的部分匹配得出：pj-k+1 pj-k+2 ...pj-1 =si-k+1 si-k+2 ...si-1
//所以，当主串中第i个字符与模式串中第j个字符比较不等时，若模式串中存在p1p2p3...pk-1=pj-k+1 pj-k+2 ...pj-1，据需将模式向右滑动至模式中第k个字符和主串的第i个字符对齐

//令next[j]=k,则next[j]表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需要重新和主串中该字符进行比较的字符的位置。
//当j=1时，next[j]=0
//当存在p1p2p3...pk-1=pj-k+1 pj-k+2 ...pj-1时，next[j]=MAX[k]
//其他情况，next[j]=1
//则匹配的过程为：
//假设以指针i和j分别指示主串和模式中正待比较的字符，令i的初值为pos，j的初值为1.若在匹配过程中si=pj，则i和j分别加1；否则，i不变，j退到next[j]的位置再比较。以此循环下去。
//直至，一，匹配成功，二，next[j]=0,此时将模式和主串继续向右滑动一个位置。


//KMP算法
int index_KMP(string s,string t,int pos)
{
	i=pos;
	j=1;
	while(i<=s[0]&&j<=t[0])
	{
		if(j==0 || s[i]==t[j])
		{
			++i;
			++j;
		}
		else 
		{
			j=next[j]
		}
	}
	if(j>t[0]) return i-t[0];	//匹配成功
}

//求next[]数组
void get_next(string t,int next[])
{
	i=1;
	next[1]=0;
	j=0;
	while(i<t[0])
	{
		if(j==0 || t[i]==t[j])
		{
			++i;
			++j;
			next[i]=j;
		}
		else
			j=next[j];
	}
}